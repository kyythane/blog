import fs from 'node:fs';
import path from 'node:path';
import frontMatter from 'front-matter';
import { sh } from 'tasksfile';

const workingDir = './src/routes/';
const maxParallelFiles = 20;

type ArticleMetadata = {
  title: string;
  url: string;
  category: string;
  tags: Array<string>;
  hidden?: boolean;
  postDate: string;
};

const processArticles = async <T>(processor: (url: string, article: string) => T | Promise<T>) => {
  const paths = fs
    .readdirSync(path.join(workingDir, 'articles'))
    .filter((path) => path.endsWith('.svelte.md'));
  const batchedPaths: Array<Array<string>> = paths.reduce(
    (acc, path) => {
      if (acc[acc.length - 1].length === maxParallelFiles) {
        return acc.concat([path]);
      } else {
        acc[acc.length - 1].push(path);
        return acc;
      }
    },
    [[]],
  );
  const chunks = await Promise.all(
    batchedPaths.map((batch) => {
      return Promise.all(
        batch.map(async (current) => {
          const uri = path.join(workingDir, 'articles/', current);
          const article = fs.readFileSync(uri, { encoding: 'utf8' });
          const strippedEnding = current.split('.')[0];
          const url = path.join('articles/', strippedEnding);
          return processor(url, article);
        }),
      );
    }),
  );
  return chunks.flat();
};

const extractMetadata = (url: string, article: string) => {
  return { ...frontMatter<Omit<ArticleMetadata, 'url'>>(article).attributes, url };
};

const updateMapping = (mapping: { [key: string]: Array<string> }, key: string, value: string) => {
  if (!mapping[key]) {
    mapping[key] = [value];
  } else {
    mapping[key].push(value);
  }
  return mapping;
};

const writeAndFormat = (file: string) => {
  const uri = path.join(workingDir, 'articles/_metadata.ts');
  fs.writeFileSync(uri, file);
  sh(`npx prettier --write ${uri}`);
  sh(`eslint --fix ${uri}`);
};

export const buildArticleDictionaries = async () => {
  const articles = await processArticles(extractMetadata);
  const categories = articles.reduce((acc, metadata) => {
    return updateMapping(acc, metadata.category, metadata.url);
  }, {});
  const tags = articles.reduce((acc, metadata) => {
    metadata.tags.forEach((tag) => updateMapping(acc, tag, metadata.url));
    return acc;
  }, {});
  const categoryList = Object.keys(categories).map((category) => ({
    category,
    urls: categories[category],
  }));
  const tagList = Object.keys(tags).map((tag) => ({ tag, urls: categories[tag] }));
  const file = applyTemplate(articles, categoryList, tagList);
  writeAndFormat(file);
};

const listTypes = `
  export type ArticleMetadata = {
    title: string;
    url: string;
    category: string;
    tags: Array<string>;
    hidden?: boolean;
    postDate: string;
  };

  export type CategoryMetadata = {
    category: string;
    urls: Array<string>;
  };

  export type TagMetadata = {
    category: string;
    urls: Array<string>;
  };
`;

const applyTemplate = (
  articles: Array<ArticleMetadata>,
  categories: Array<{ category: string; urls: Array<string> }>,
  tags: Array<{ tag: string; urls: Array<string> }>,
) => {
  const articleString = JSON.stringify(articles);
  const categoryString = JSON.stringify(categories);
  const tagString = JSON.stringify(tags);
  return `
    // This file is autogenerated by scripts/generate_page_data
    ${listTypes}
    export const articleList = ${articleString};
    export const catagoryList = ${categoryString};
    export const tagList = ${tagString};
   `;
};
